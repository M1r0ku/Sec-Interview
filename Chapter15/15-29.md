### 如何在没有 /tmp 写入权限的情况下，寻找替代的、可执行文件的临时存放位置

**一、常规替代目录的优先级侦察**

我会优先检查那些默认情况下可能拥有写入权限，且常被系统或应用程序忽略的目录

**1. 用户 Home 目录和配置文件**

如果我已经获得了某个用户的 Shell 访问权限，那么该用户自己的 Home 目录或其下的某些子目录通常是最佳的落脚点

- **用户的家目录 (`$HOME`):**
  - `/home/user/` 或 `~/`
  - **优点:** 绝对有写入权限
  - **缺点:** 容易被用户自己的活动或安全软件（如 EDR/AV）监控
- **缓存和配置目录:**
  - `$HOME/.cache/`：应用程序缓存目录
  - `$HOME/.config/`：用户配置目录
  - `$HOME/.local/share/`：本地应用数据共享目录
- **临时日志/历史文件:**
  - `/var/tmp/`：某些系统允许普通用户写入
  - 检查 `$HISTFILE` 变量指向的路径

**2. Web 应用或服务目录**

如果目标是一个 Web 服务器，Web 服务运行账户可能对某些目录拥有写入权限，尤其是在 Web 根目录之外

- **Session 目录:** 如果 Web 服务器启用了 PHP 或其他脚本语言，检查其 **Session 存储路径**，这些目录通常需要具备写入权限
- **上传目录:** 寻找 Web 应用中用于文件上传的目录，即使配置了文件类型限制，也可能用于存放和执行二进制文件（但这通常需要绕过 Web 应用逻辑）

**3. 共享目录与系统目录的误配置**

我会寻找那些权限配置错误的目录，尤其是那些允许 `Others` 组写入的目录

- **共享库和配置:**
  - `/opt/` 或 `/usr/local/` 下的子目录
  - **`chmod -R o+w /some/dir`** 导致的系统目录权限被过度放宽
- **服务/数据目录:** 检查 `/var/lib/` 或 `/var/run/` 下的子目录，某些服务可能被配置为以普通用户权限运行，并对特定子目录具有写入权限

****

**二、系统化查找：权限和挂载点分析**

这才是渗透测试的精髓：系统化地分析文件系统，找出既可写又可执行的目录。

**1. 文件系统权限分析（查找可写目录）**

使用 `find` 命令结合 `perm` 标志，扫描整个文件系统，查找当前用户具有写入权限（`w`）的目录

```bash
# 查找根目录下，对当前用户（通常通过 "others" 权限）可写的目录
# (需要优化，避免扫描 /proc, /sys 等虚拟文件系统)
find / -path /proc -prune -o -path /sys -prune -o -type d -perm /o+w 2>/dev/null 

# 简化版本，可能产生大量输出
find / -writable -type d 2>/dev/null
```

我会将输出结果导入一个文件，然后逐一检查这些目录，看是否能成功创建一个文件

**2. 挂载点分析（查找 `noexec` 限制）**

即使一个目录是可写的，如果其所在的文件系统是以 `noexec` 选项挂载的，那么在该目录下执行任何文件都将失败

检查 `/etc/fstab` 或使用 `mount` 命令来查看所有挂载点的选项：

```bash
mount
```

**关注点：**

- 如果 `/home` 或 `/var` 目录单独挂载，它们可能存在 `noexec` 限制
- 如果找到一个未被 `noexec` 标记的**可写目录**（例如，一个不常见的 `/data` 分区），那就是完美的替代位置

**3. 进程关联目录**

通过查看进程信息，有时能发现服务正在使用的、拥有特定权限的临时目录

```bash
# 检查 LSASS 进程（或任何高权限服务）的当前工作目录或打开的文件句柄
ls -l /proc/[PID]/cwd
ls -l /proc/[PID]/fd
```

这可能暴露出一些不为人知且权限配置宽松的目录路径

****

**三、内存加载与文件描述符**

如果所有的文件系统侦察都失败了，即找不到任何可写且可执行的目录，那么最后的方案是**不将文件写入磁盘**

**1. 内存加载（无文件执行）**

- **反射式 DLL 注入/内存 Payload:** 使用 Metasploit 的 **`migrate`** 或 **PowerShell Empire** 等工具，将 Shellcode 或 PE 文件直接加载到内存中的一个合法进程中执行。这避免了对临时目录的需求
- **`/dev/shm` 策略:** 在某些 Linux 系统上，`/dev/shm` 是一个基于内存的文件系统（tmpfs）。它通常允许写入和执行，但可能受到 `/tmp` 同样的限制。不过，因为它在 RAM 中，比物理磁盘上的 `/tmp` 更难被取证分析

**2. 使用文件描述符技巧**

在 Linux 系统中，可以利用文件描述符在不创建可执行文件的情况下运行脚本或二进制文件：

```bash
# 示例：将二进制数据通过管道传输到 bash 解释器
echo 'ELF_BINARY_BASE64_STRING' | base64 -d > /dev/fd/0 | /bin/bash
```

这种方法虽然复杂，但能有效避免将可执行文件保存到磁盘